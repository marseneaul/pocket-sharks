import { getContext } from './canvas.ts';
import { DMG_PALETTE, FONT_CHAR_WIDTH, FONT_CHAR_HEIGHT } from '../constants.ts';

// 8x8 pixel font - we'll generate a simple bitmap font
// Each character is stored as 8 bytes (8 rows of 8 bits)
const FONT: Record<string, number[]> = {
  'A': [0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
  'B': [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
  'C': [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
  'D': [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
  'E': [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00],
  'F': [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00],
  'G': [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
  'H': [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
  'I': [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
  'J': [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00],
  'K': [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
  'L': [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
  'M': [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
  'N': [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
  'O': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
  'P': [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
  'Q': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00],
  'R': [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00],
  'S': [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
  'T': [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
  'U': [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
  'V': [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
  'W': [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
  'X': [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
  'Y': [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
  'Z': [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
  '0': [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00],
  '1': [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
  '2': [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00],
  '3': [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
  '4': [0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00],
  '5': [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
  '6': [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
  '7': [0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00],
  '8': [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
  '9': [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00],
  ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
  ',': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30],
  '!': [0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00],
  '?': [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00],
  '-': [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
  '/': [0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00],
  ':': [0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00],
  '\'': [0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
  '(': [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
  ')': [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
  '>': [0x00, 0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0x00],
  '<': [0x00, 0x06, 0x0C, 0x18, 0x0C, 0x06, 0x00, 0x00],
  '[': [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00],
  ']': [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00],
  '=': [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00],
  '+': [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
  '*': [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
  '#': [0x24, 0x24, 0x7E, 0x24, 0x7E, 0x24, 0x24, 0x00],
  '%': [0x62, 0x64, 0x08, 0x10, 0x20, 0x4C, 0x8C, 0x00],
  '@': [0x3C, 0x42, 0x5A, 0x5A, 0x5C, 0x40, 0x3E, 0x00],
  '_': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00]
};

export function drawChar(char: string, x: number, y: number, colorIndex: number = 0): void {
  const ctx = getContext();
  const bitmap = FONT[char.toUpperCase()];

  if (!bitmap) return;

  const colors = [DMG_PALETTE.BLACK, DMG_PALETTE.DARK, DMG_PALETTE.LIGHT, DMG_PALETTE.WHITE];
  ctx.fillStyle = colors[colorIndex];

  for (let row = 0; row < 8; row++) {
    const rowData = bitmap[row];
    for (let col = 0; col < 8; col++) {
      if (rowData & (0x80 >> col)) {
        ctx.fillRect(Math.floor(x) + col, Math.floor(y) + row, 1, 1);
      }
    }
  }
}

export function drawText(text: string, x: number, y: number, colorIndex: number = 0): void {
  let cursorX = x;
  for (const char of text) {
    drawChar(char, cursorX, y, colorIndex);
    cursorX += FONT_CHAR_WIDTH;
  }
}

export function measureText(text: string): number {
  return text.length * FONT_CHAR_WIDTH;
}

// Consistent line height for text spacing
export const LINE_HEIGHT = FONT_CHAR_HEIGHT + 2; // 10px (8 + 2 spacing)

// Center text horizontally within a given width
export function drawTextCentered(text: string, x: number, width: number, y: number, colorIndex: number = 0): void {
  const textWidth = measureText(text);
  const centeredX = x + Math.floor((width - textWidth) / 2);
  drawText(text, centeredX, y, colorIndex);
}

// Right-align text within a given width
export function drawTextRightAligned(text: string, x: number, width: number, y: number, colorIndex: number = 0): void {
  const textWidth = measureText(text);
  const rightX = x + width - textWidth;
  drawText(text, rightX, y, colorIndex);
}

// Typewriter state for animated text
interface TypewriterState {
  text: string;
  x: number;
  y: number;
  maxWidth: number;
  currentIndex: number;
  complete: boolean;
}

let typewriter: TypewriterState | null = null;

export function startTypewriter(text: string, x: number, y: number, maxWidth: number): void {
  typewriter = {
    text,
    x,
    y,
    maxWidth,
    currentIndex: 0,
    complete: false
  };
}

export function advanceTypewriter(): void {
  if (typewriter && !typewriter.complete) {
    typewriter.currentIndex++;
    if (typewriter.currentIndex >= typewriter.text.length) {
      typewriter.complete = true;
    }
  }
}

export function completeTypewriter(): void {
  if (typewriter) {
    typewriter.currentIndex = typewriter.text.length;
    typewriter.complete = true;
  }
}

export function isTypewriterComplete(): boolean {
  return typewriter?.complete ?? true;
}

export function drawTypewriter(): void {
  if (!typewriter) return;

  const visibleText = typewriter.text.substring(0, typewriter.currentIndex);
  const words = visibleText.split(' ');

  let cursorX = typewriter.x;
  let cursorY = typewriter.y;
  const lineHeight = FONT_CHAR_HEIGHT + 2;

  for (const word of words) {
    const wordWidth = measureText(word + ' ');

    // Word wrap
    if (cursorX + wordWidth > typewriter.x + typewriter.maxWidth && cursorX !== typewriter.x) {
      cursorX = typewriter.x;
      cursorY += lineHeight;
    }

    drawText(word + ' ', cursorX, cursorY);
    cursorX += wordWidth;
  }
}

export function clearTypewriter(): void {
  typewriter = null;
}
